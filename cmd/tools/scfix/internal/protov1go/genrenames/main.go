// Command genrenames generates the service_renames_gen.go file by scanning proto files.
// The tool finds all proto files in protodir and inspects them to see if their service declarations have changed
// between v0 and v1.
// Each changed declaration will require updates in Go code, which this tool helps facilitate.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/smart-core-os/sc-bos/internal/compat/protopkg"
)

var (
	output   = flag.String("output", "service_renames_gen.go", "output file path")
	protoDir = flag.String("protodir", "../../../../../proto", "path to proto directory relative to this tool")
)

var (
	packageRe = regexp.MustCompile(`(?m)^package\s+([\w.]+)\s*;`)
	serviceRe = regexp.MustCompile(`(?m)^service\s+(\w+)\s*\{`)
)

const fileTemplate = `// Code generated by genrenames. DO NOT EDIT.

package protov1go

// serviceRenames maps old service names to new service names from v0->v1 migration.
// This is generated by scanning proto files and using protopkg.V1ToV0 to determine renames.
var serviceRenames = map[string]string{
{{- range $old, $new := .Renames}}
	"{{$old}}": "{{$new}}",
{{- end}}
}
`

func main() {
	flag.Parse()

	// Resolve proto directory
	protoPath, err := filepath.Abs(*protoDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error resolving proto directory: %v\n", err)
		os.Exit(1)
	}

	if _, err := os.Stat(protoPath); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Proto directory does not exist: %s\n", protoPath)
		os.Exit(1)
	}

	// Discover service renames
	renames, err := discoverServiceRenames(protoPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error discovering renames: %v\n", err)
		os.Exit(1)
	}

	// Generate the output file
	tmpl, err := template.New("renames").Parse(fileTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create(*output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	data := struct {
		Renames map[string]string
	}{
		Renames: renames,
	}

	if err := tmpl.Execute(f, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d service rename(s)\n", *output, len(renames))
}

func discoverServiceRenames(protoDir string) (map[string]string, error) {
	renames := make(map[string]string)

	err := filepath.WalkDir(protoDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || !strings.HasSuffix(d.Name(), ".proto") {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("reading %s: %w", path, err)
		}

		// Extract package name
		pkgMatch := packageRe.FindSubmatch(content)
		if len(pkgMatch) < 2 {
			return nil
		}
		v1Package := string(pkgMatch[1])

		// Only process v1 packages
		if !strings.Contains(v1Package, ".v1") {
			return nil
		}

		// Extract all services in this file
		serviceMatches := serviceRe.FindAllSubmatch(content, -1)
		for _, match := range serviceMatches {
			if len(match) < 2 {
				continue
			}
			v1Service := string(match[1])

			// Call V1ToV0 to see what the old service name was
			v1FQN := v1Package + "." + v1Service
			v0FQN := protopkg.V1ToV0(v1FQN)
			_, v0Service := splitPackageService(v0FQN)

			// If the service name changed, record it
			if v0Service != v1Service {
				renames[v0Service] = v1Service
			}
		}

		return nil
	})

	return renames, err
}

func splitPackageService(fqn string) (pkg, service string) {
	lastDot := strings.LastIndex(fqn, ".")
	if lastDot == -1 {
		return "", fqn
	}
	return fqn[:lastDot], fqn[lastDot+1:]
}

// Package store provides a SQLite-based data storage layer for the cloudsim application.
//
// # Entities and Relationships
//
// Sites represent physical locations. Nodes are BOS controllers associated with a site.
// ConfigVersions store versioned binary configurations, associated with a node.
// Deployments track the status of deploying a config version (PENDING, IN_PROGRESS, COMPLETED, FAILED).
//
// Deleting a site cascades to all associated nodes, config versions, and deployments.
//
// # Usage
//
// All operations must occur within Read or Write transactions. List queries use page token
// pagination (ordered by ID). This package uses sqlc to generate type-safe code from SQL.
//
// To regenerate after modifying queries/queries.sql or migrations/*.sql, use `go generate`
package store

import (
	"context"
	"database/sql"
	"embed"

	"go.uber.org/zap"

	"github.com/smart-core-os/sc-bos/cmd/cloudsim/internal/store/queries"
	"github.com/smart-core-os/sc-bos/internal/sqlite"
)

const appID = 0x5C0502

//go:embed migrations/*.sql
var migrationsFS embed.FS

var schema = sqlite.MustLoadVersionedSchema(migrationsFS, "migrations")

// Store provides access to the cloudsim SQLite database.
// Use OpenStore for persistent storage or NewMemoryStore for non-persistent uses e.g. testing.
// All operations must be performed within Read or Write transactions.
type Store struct {
	db *sqlite.Database
}

// OpenStore opens a SQLite database at the given path and applies migrations to update to the latest schema version.
// The database file will be created if it doesn't exist.
// Returns an error if the database cannot be opened or migrations fail.
func OpenStore(ctx context.Context, path string, logger *zap.Logger) (*Store, error) {
	db, err := sqlite.Open(ctx, path,
		sqlite.WithLogger(logger),
		sqlite.WithApplicationID(appID),
	)
	if err != nil {
		return nil, err
	}

	err = db.Migrate(ctx, schema)
	if err != nil {
		return nil, err
	}

	return &Store{
		db: db,
	}, nil
}

// NewMemoryStore creates an in-memory SQLite database for testing.
// The database is fully functional but exists only in memory and will be
// lost when the store is closed. Panics if migrations fail (indicates broken schema).
func NewMemoryStore(logger *zap.Logger) *Store {
	db := sqlite.OpenMemory(
		sqlite.WithLogger(logger),
		sqlite.WithApplicationID(appID),
	)

	err := db.Migrate(context.Background(), schema)
	if err != nil {
		// this can only happen if the migrations are broken
		panic(err)
	}

	return &Store{db: db}
}

// Close closes the database connection.
func (s *Store) Close() error {
	return s.db.Close()
}

// Read executes a read-only transaction.
// Multiple concurrent read transactions are allowed.
// The transaction is automatically rolled back when the function returns.
func (s *Store) Read(ctx context.Context, f func(tx *Tx) error) error {
	return s.db.ReadTx(ctx, func(tx *sql.Tx) error {
		storeTx := &Tx{Queries: queries.New(tx)}
		return f(storeTx)
	})
}

// Write executes a read-write transaction.
// Only one write transaction can execute at a time.
// The transaction is automatically committed if the function returns nil,
// or rolled back if it returns an error.
func (s *Store) Write(ctx context.Context, f func(tx *Tx) error) error {
	return s.db.WriteTx(ctx, func(tx *sql.Tx) error {
		storeTx := &Tx{Queries: queries.New(tx)}
		return f(storeTx)
	})
}

// Tx wraps the generated queries with additional transaction methods.
// Access to Tx is only available within Read or Write transaction callbacks.
// All query methods are generated by sqlc from queries/queries.sql.
type Tx struct {
	*queries.Queries
}
